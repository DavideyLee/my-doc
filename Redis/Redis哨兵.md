# Redis哨兵（sentinel）

哨兵为Redis提供了高可用性。意味着实际中可以使用哨兵创建一个非人工干预的、可以抵抗特定类型故障的Redis部署结构。此外哨兵还提供了监控、通知等附属功能。Redis哨兵在宏观层面上提供完整功能列表为：

* 监控。不断检测主节点和从节点的工作是否符合预期。
* 通知。被监控的实例出现错误时，通过API通知系统管理员或其他程序
* 自动故障恢复。如果主节点无法正常工作，哨兵会启动故障转移程序。推选一个从节点替换主节点，其他从节点重新配置到新主节点。并通知应用程序新的主节点地址。
* 配置提供者。为客户端服务发现提供权威来源：客户端连接到哨兵来获取当前主节点的地址。

## 分布式特性

Redis哨兵是一个分布式系统。哨兵被设计为在多个哨兵进程互相协同的配置中运行。多个协同进程的优势为：

1. 故障检测须由多个哨兵对一个指定节点不再可用的事实达成一致，这样可以降低误报概率。
2. 即使部分哨兵进程无法工作时，哨兵服务依然可用。使得系统更加健壮。使用一个自身存在单点故障的故障恢复系统一点也不好玩。

哨兵、Redis实例和客户端的总和也组成了一个大型的分布式系统。本文将从哨兵的基本信息到更复杂的哨兵工作原理对其逐步进行介绍。

## 快速入门

### 使用版本

当前版本为Sentinel 2版本。Redis2.8和3.0是使用哨兵的稳定版本。附带Redis 2.6的Sentinel 1版本已经弃用。

### 运行

使用redis-sentinel脚本可以运行哨兵：

<pre>
    redis-sentinel /path/to/sentinel.conf
</pre>

或者使用redis-server脚本按哨兵模式启动：

<pre>
    redis-server /path/to/sentiel.conf --sentinel
</pre>

两种方式结果相同。哨兵在启动时会强制要求指定配置文件，该配置是系统用于保存当前状态的，以便重启时加载。如果没指定配置文件或指定文件没有写权限，则启动将被拒绝。

哨兵启动是会默认监听26379端口，所以服务器中的26379端口必须对其他服务器的哨兵实例打开，以便接收它们的连接。

### 一些注意事项

1. 你需要至少3个哨兵实例来构建一个健壮的部署结构
2. 三个实例应该位于（出现故障）互不影响的服务器或虚拟机上。
3. 哨兵不能保证被确认的更新操作不会丢失。
4. 哨兵需要客户端支持。多数客户端都会支持哨兵，但并非所有
5. 如果没有经过不断的测试，安全的高可用性的设置是不存在的。你可能会出现配置错误的情况，而当这个错误明显暴露出来的时候已经晚了。
6. 哨兵、Docker、NAT或端口映射在一起使用时需要注意：Docker会执行端口重映射，会破坏哨兵自动发现其他哨兵进程和从节点列表的能力。

### 哨兵配置

Redis源码中有名为sentinel.conf的文件，是一个自描述的示例配置。一个典型的最小化的配置文件如下：

<pre>
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 60000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1

sentinel monitor resque 192.168.1.3 6380 4
sentinel down-after-milliseconds resque 10000
sentinel failover-timeout resque 180000
sentinel parallel-syncs resque 5
</pre>

配置只需要指定被监控的主节点，并为每个主节点命名。从节点不需指定，会被自动发现。哨兵会自动将从节点的信息更新到配置中，以便重启时直接获取这些信息。每次从节点被选举替换主节点以及每次发现新哨兵都会将配置重写。

上面的例子中监控了两个Redis实例集合，一个集合名为mymaster，另一个为resque。Sentinel monitor语句的参数为：

<pre>
    sentinel monitor <master-group-name> <ip> <port> <quorum>
</pre>

实例配置第一行告诉哨兵去监控一个名为mymaster的主节点，地址为127.0.0.1，端口为6379，表决者数量为2。表决者数量参数的含义为：

* 表决者数量是认同一个主节点无法访问的哨兵数量，以便将其标记为故障状态，并最终启动故障转移程序。
* 表决者数量仅用于检测故障。为了真正执行故障转移，其中一个哨兵需要被选为领袖并被授权执行故障转移。领袖只能由大多数哨兵进程投票产生。

假设有5个哨兵进程，表决者数量为2。于是会发生：

* 如果两个哨兵同时认为一个主节点无法访问，其中一个哨兵会尝试一次故障转移
* 如果至少存在3个可访问的哨兵，故障转移会被授权并真正的启动。

也就是说，在实际使用中如果多数哨兵进程无法互相访问，则故障转移无法执行。

### 其他配置项

其他的配置项格式均为：

<pre>
    sentinel <option_name> <master_name> <option_value>
</pre>

选项的用途为：

* down-after-milliseconds是哨兵开始认为一个实例出现故障时，该实例无法访问（要么不回复ping，要么回复错误）持续的时间，单位为毫秒。
* parallel-syncs设置了在故障转移后，可以同时重配置为复制新主节点的从节点数量。值越小，故障转移的完成时间消耗越多。如果从节点配置为可以服务旧数据，你可能不想所有从节点同时同步主节点数据。虽然复制是非阻塞的，但同步时依然存在一段暂停服务的时间，以便从主节点加载大块数据。如希望保证同一时间只有一个从节点不可用，那么该选项就设置为1。

其余选项会在后续章节中介绍。所有配置参数都可以使用SENTINEL SET指令在运行时修改。

### 哨兵部署实例

本节会用到以下图例：

下图表示一个虚拟机或物理机，取名为“盒子”

<pre>
+--------------------+
| This is a computer |
| or VM that fails   |
| independently. We  |
| call it a "box"    |
+--------------------+
</pre>

下图表示哪些程序正在运行

<pre>
+-------------------+
| Redis master M1   |
| Redis Sentinel S1 |
+-------------------+
</pre>

下图表示不同盒子之间可以互相访问

<pre>
+-------------+               +-------------+
| Sentinel S1 |---------------| Sentinel S2 |
+-------------+               +-------------+
</pre>

下图表示网络断开

<pre>
+-------------+                +-------------+
| Sentinel S1 |------ // ------| Sentinel S2 |
+-------------+                +-------------+
</pre>

此外

* M1, M2, M3, ..., Mn表示主节点
* R1, R2, R3, ..., Rn表示从节点
* S1, S2, S3, ..., Sn表示哨兵
* C1, C2, C3, ..., Cn表示客户端
* 由哨兵触发的角色改变使用方括号表示，如 [M1] 表示实例由于哨兵的干预而变成了主节点。

#### 示例1：只有两个哨兵

<pre>
+----+         +----+
| M1 |---------| R1 |
| S1 |         | S2 |
+----+         +----+

quorum = 1
</pre>

如果M1和S1所在的盒子停止工作，S2将无法授权故障转移，系统将不可用。

<pre>
+----+           +------+
| M1 |----//-----| [M1] |
| S1 |           | S2   |
+----+           +------+
</pre>

在上图中，我们创建了两个对称的主节点。客户端可以分别在两端写入，当网络恢复正常后，没有办法判断哪边的配置是正确的。

#### 示例2：三个盒子的基本设置

<pre>
       +----+
       | M1 |
       | S1 |
       +----+
          |
+----+    |    +----+
| R2 |----+----| R3 |
| S2 |         | S3 |
+----+         +----+

quorum = 2
</pre>

在每种哨兵设置中，Redis总会出现写操作丢失的风险。然而在上面的示例中，由于客户端可能会访问旧的主节点，写操作丢失的风险会更高。

<pre>
         +----+
         | M1 |
         | S1 | <- C1 (writes will be lost)
         +----+
            |
            /
            /
+------+    |    +----+
| [M2] |----+----| R3 |
| S2   |         | S3 |
+------+         +----+
</pre>

网络分区将M1隔离开，R2成为主节点，C1与M1在同一分区。此时C1可能会执行写操作。由于网络分区恢复后，M1将被配置为M2的从节点，C1的写操作将永久丢失。

此问题使用下面的Redis复制特性可以得到缓解。如果主节点检测到自己无法向指定数量的从节点复制写操作，该特性允许停止接收写操作。

<pre>
min-slaves-to-write 1
min-slaves-max-lag 10
</pre>

使用上述配置，如果无法向至少1个从节点复制，主节点将停止接收写操作。无法向从节点复制写操作实际意味着从节点或者无法连接，或者没有回复确认的时间（秒）超过配置的max-lag。因此M1将在10秒后变得不可用。然而这种特性也有弊端，如果两个从节点同时故障，主节点也将不可用。

### 示例3：哨兵在客户端节点

有时我们只有一主一从两个节点。上一个示例中的配置是行不通的，我们可以采纳下面的方式，将哨兵与客户端放置在一个盒子中：

<pre>
            +----+         +----+
            | M1 |----+----| R1 |
            | S1 |    |    | S2 |
            +----+    |    +----+
                      |
         +------------+------------+
         |            |            |
         |            |            |
      +----+        +----+      +----+
      | C1 |        | C2 |      | C3 |
      | S1 |        | S2 |      | S3 |
      +----+        +----+      +----+

   quorum = 2
</pre>

### 示例4：哨兵在客户端节点且客户端少于三个

如果客户端节点少于三个，示例3中的设置将无法使用。本例中我们采用以下设置：

<pre>
            +----+         +----+
            | M1 |----+----| R1 |
            | S1 |    |    | S2 |
            +----+    |    +----+
                      |
               +------+-----+
               |            |  
               |            |
            +----+        +----+
            | C1 |        | C2 |
            | S3 |        | S4 |
            +----+        +----+

      quorum = 3
</pre>

### 哨兵、Docker、NAT和可能的问题

Docket使用一种称为端口映射的技术：在Docker容器中运行的程序可能会被使用不同的端口暴露给外界，而不是程序以为正在使用的端口。在同一服务器同时使用相同端口运行多个容器时很有用。Docket不是唯一遇到这种情况的软件系统，还存在其他的NAT设置会让端口重新映射，甚至是IP地址。

IP和端口的重映射会以两种方式对哨兵产生影响：

1. 自动发现其他哨兵的功能无法使用。是因为该功能基于hello消息实现的，该消息是每个哨兵表名自己在监听哪个IP和端口。然而哨兵无法知道IP或端口被重映射了，因此它正常声明的消息对其他节点可能是错误的。
2. INFO指令输出的从节点列表。IP地址是由主节点根据检查TCP连接的远程端检测出来的，但端口是从节点在握手时自己通告的。与上一条类似，这个端口可能是错误的。

因此哨兵使用INFO指令自动发现的从节点都是无法使用的，也将导致无法对主节点进行故障转移。因此目前哨兵无法监控部署在Docker上的主节点和从节点的集合，除非命令Docket按1:1映射端口。

对于第一个问题，假设需要在Docker中（或其他重映射端口的NAT环境中）使用哨兵实例，可以使用以下两个配置来让哨兵声明指定的IP和端口：

<pre>
sentinel announce-ip <ip>
sentinel announce-port <port>
</pre>

Docker可以使用host networking模式运行（参考--net=host参数），该模式不会对哨兵产生影响，因为端口不会被重映射。

## 上手指南

本节是一个展示如何配置3个哨兵实例并与其交互的指南，读者可以尽快的运行系统。

假设哨兵实例使用5000、5001和5002端口，一主一从节点分布使用6379和6380端口。IP均使用127.0.0.1。三个哨兵配置类似于：

<pre>
port 5000
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 60000
sentinel parallel-syncs mymaster 1
</pre>

### 查询主节点状态

<pre>
$ redis-cli -p 5000
127.0.0.1:5000> sentinel master mymaster
 1) "name"
 2) "mymaster"
 3) "ip"
 4) "127.0.0.1"
 5) "port"
 6) "6379"
 7) "runid"
 8) "953ae6a589449c13ddefaee3538d356d287f509b"
 9) "flags"
10) "master"
11) "link-pending-commands"
12) "0"
13) "link-refcount"
14) "1"
15) "last-ping-sent"
16) "0"
17) "last-ok-ping-reply"
18) "735"
19) "last-ping-reply"
20) "735"
21) "down-after-milliseconds"
22) "5000"
23) "info-refresh"
24) "126"
25) "role-reported"
26) "master"
27) "role-reported-time"
28) "532439"
29) "config-epoch"
30) "1"
31) "num-slaves"
32) "1"
33) "num-other-sentinels"
34) "2"
35) "quorum"
36) "2"
37) "failover-timeout"
38) "60000"
39) "parallel-syncs"
40) "1"
</pre>

可以看到，哨兵打印了大量的主节点信息。我们可能会对其中一些很感兴趣：

1. num-other-sentinels是2，可以知道该哨兵已经检测到另外两个检测该主节点的哨兵。你可以在日志中看到+sentinel事件。
2. flags只有master。如果主节点故障，我们会期望还能看到s\_down或o\_down标记。
3. num-slaves是1。哨兵能检测到有一个从节点附属到主节点上。

尝试下面两条指令可以获得更多信息：

<pre>
SENTINEL slaves mymaster
SENTINEL sentinels mymaster
</pre>

第一条提供从节点的类似信息，第二条是关于其他哨兵的。

### 获取当前节点地址

哨兵可以作为配置提供者，使用以下指令可以获取当前活跃主节点的访问地址：

<pre>
127.0.0.1:5000> SENTINEL get-master-addr-by-name mymaster
1) "127.0.0.1"
2) "6379"
</pre>

### 测试故障转移

下面我们可以杀掉主节点来查看配置是否变更。执行下面指令：

<pre>
    redis-cli -p 6379 DEBUG sleep 30
</pre>

该指令会通过使主节点睡眠30秒从而无法被访问。此时如果查看哨兵的日志，可以看到许多操作：

1. 哨兵检测到主节点故障，出现+sdown事件。
2. 之后事件升级为+odown。表示多个哨兵已经就无法访问主节点的实时达成一致。
3. 选举出一个哨兵启动第一次故障转移尝试。
4. 发生故障转移

此时查询mymaster主节点地址将会得到不同的结果：

<pre>
127.0.0.1:5000> SENTINEL get-master-addr-by-name mymaster
1) "127.0.0.1"
2) "6380"
</pre>

## 哨兵API

哨兵提供了一个API来检查自己的状态、查看主从节点的健康状况、订阅通知以及在线修改哨兵配置。哨兵默认使用26379端口运行，并使用Redis协议接收指令。因此使用redis-cli或其他客户端都可以与哨兵通信。
使用Pub/Sub可以接收哨兵推送的消息，每次发生某些事件时（如故障转移或一个实例处于错误状态等）哨兵会主动将通知推送给客户端。

### 哨兵指令

下面是哨兵支持的指令（不包含修改配置的指令）：

<pre>
* PING。该指令仅是返回PONG
* SENTINEL masters。显示主节点列表及状态。
* SENTINEL master <master name>。显示指定主节点的状态和信息
* SENTINEL slaves <master name>。显示指定主节点的从节点列表和状态。
* SENTINEL sentinels <master name>。显示指定主节点的哨兵列表和状态。
* SENTINEL get-master-addr-by-name <master name>。返回指定主节点的访问地址。如果故障转移正在进行或已成功完成，结果为新选举的从节点地址。
* SENTINEL reset <pattern>。重置匹配的所有主节点。pattern参数使用通配符格式。重置操作会清空主节点之前的所有状态，移除每个已发现的、与指定主节点相关的从节点和哨兵信息。
* SENTINEL failover <master name>。强制执行故障转移，且不会征求其他哨兵的同意。
* SENTINEL ckquorum <master name>。检查当前配置是否可以满足quorum数量要求，以及授权故障转移的要求。该指令应该在监控系统中使用，来检测哨兵部署是否正常。
* SENTINEL flushconfig。强制哨兵将配置重写到磁盘中，包括当前状态。哨兵通常在每次状态变化是重写配置。然而有些时候配置文件可能因为出现误操作、磁盘故障等情况而丢失。此时可以手动重写配置。
</pre>

### 在线配置

在Redis 2.8.4版本之后，哨兵提供了用于添加、删除或修改指定主节点配置的API。需要注意的是如果有多个哨兵，应该将修改应用到所有哨兵实例中，以便它们正常工作。一个实例的配置修改无法自动传播到其他哨兵实例中。下面是更新配置的指令列表：

<pre>
* SENTINEL MONITOR <name> <ip> <port> <quorum>。该指令使哨兵开始监控新的主节点。与配置文件中sentinel monitor配置不同，该指令的ip参数只能为IP地址，不能为域名。
* SENTINEL REMOVE <name>。该指令用来移除对指定的主节点的监控。
* SENTINEL SET <name> <option> <value>。该指令用来修改指定主节点的配置参数。可以指定多个option/value对。所有在sentinel.conf中的参数都可以用该指令设置。
</pre>

下面示例用来修改down-after-milliseconds的配置：

<pre>
SENTINEL SET objects-cache-master down-after-milliseconds 1000
</pre>

该指令还可以用来修改quorum参数，而不用先SENTINEL REMOVE再SENTINEL MONITOR：

<pre>
SENTINEL SET objects-cache-master quorum 5
</pre>

注意，没有对应的GET指令来获取配置，获取配置须使用SENTINEL MASTER指令。

### 添加和删除哨兵

因为有自动发现的机制，添加哨兵非常简单。只需要将新增哨兵配置为监控当前活跃的主节点。哨兵在10秒内将获得其他哨兵的列表以及从节点列表。
如果需要一次添加多个哨兵，建议一个一个添加，等其他所有哨兵都发现一个新增哨兵后再添加下一个。这样可以保证在网络分区时，多数哨兵可以访问。
最后使用SENTINEL MASTER指令检查是否所有的哨兵对哨兵总数达成一致。

删除哨兵会有些麻烦，哨兵无法遗忘已知的哨兵，即使它们很长一段时间内无法被访问。删除方法为：

1. 停止想要删除的哨兵进程
2. 向其他哨兵实例发送SENTINEL RESET * 指令，一个接一个且每次至少等待30秒。
3. 使用SENTINEL MASTER指令检查所有哨兵输出的活跃哨兵数量是一致的。

### 删除旧的主节点或无法访问的从节点

哨兵无法遗忘指定主节点的从节点，即使长时间内无法访问它们。因为哨兵应该在网络分区或故障事件之后将回归的从节点正确配置。此外，故障主节点实际上会被添加到新主节点的从节点列表中，当该节点可用时哨兵会对其重新配置。

有时你会想在监控列表中永久删除一个从节点（或一个旧的主节点）。你需要向所有哨兵实例发送SENTINEL RESET mastername指令。之后每个哨兵只会添加目前正在复制指定主节点的从节点。

### Pub/Sub消息

客户端可以使用SUBSCRIBE或PSUBSCRIBE指令来订阅哨兵的频道以及获取特定事件的通知。
频道名称与事件名称相同，如+sdown频道将接收所有关于实例进入SDOWN（SDOWN意思是目前正在查询的哨兵认为该实例无法访问）状态的通知。
如获取所有消息，只须使用PSUBSCRIBE * 指令。

下面是可以接收的所有频道和消息格式。第一个单词是频道或事件名称，其余的是数据格式：

<pre>
* +reset-master <instance details> —— 主节点被重置。
* +slave <instance details> —— 新的从节点被检测到。
* +failover-state-reconf-slaves <instance details> —— 故障转移状态改变到reconf-slaves状态
* +failover-detected <instance details> —— 检测到另一个哨兵或其他外部实体启动了一次故障转移。
* +slave-reconf-sent <instance details> —— 哨兵领袖向该实例发送SLAVEOF指令来重新配置。
* +slave-reconf-inprog <instance details> —— 显示正在被重新配置的从节点将要成为新主节点的从节点，但数据同步过程尚未完成。
* +slave-reconf-done <instance details> —— 从节点已与新主节点同步。
* -dup-sentinel <instance details> —— 指定主节点因为重复而将一个或多个哨兵移除。
* +sentinel <instance details> —— 检测到该主节点有新的哨兵加入。
* +sdown <instance details> —— 指定实例处于主观宕机状态。
* -sdown <instance details> —— 指定实例不再处于主观宕机状态。
* +odown <instance details> —— 指定实例处于客观宕机状态。
* -odown <instance details> —— 指定实例不再处于客观宕机状态。
* +new-epoch <instance details> —— current epoch更新了。
* +try-failover <instance details> —— 正在进行新一轮的故障转移，在等待多数哨兵选举领袖。
* +elected-leader <instance details> —— 在当前纪元赢得选举，可以执行故障转移。
* +failover-state-select-slave <instance details> —— 在选举从节点
* no-good-slave <instance details> —— 没有可选举的健康从节点。过段时间会重试
* selected-slave <instance details> —— 找到可选举的从节点
* failover-state-send-slaveof-noone <instance details> —— 正在重试将从节点重配置为主节点，等待从节点转换。
* failover-end-for-timeout <instance details> —— 故障转移因为超时而终止。无论如何从节点最终会被配置为新主节点的副本。
* failover-end <instance details> —— 故障转移成功结束。所有从节点似乎被配置为新主节点的副本。
* switch-master <master name> <oldip> <oldport> <newip> <newport> —— 主节点新的访问地址为指定值。大多数外部用户会对此信息感兴趣。
* +tilt —— 进入Tilt模式
* -tilt —— 退出Tilt模式
</pre>

### 处理-BUSY状态

-BUSY状态会由一个Redis实例返回，当一段Lua脚本运行时间超过配置的Lua脚本时间限制时返回该状态。此时在触发故障转移前，哨兵会尝试发送SCRIPT KILL指令。如果脚本只有读操作，该指令会成功。如果该实例之后还处于错误状态，最终它将被故障转移。

### 从节点优先级

Redis实例有一个名为slave-priority的配置参数。从节点会将该信息在INFO结果中返回，哨兵使用它来挑选执行故障转移的从节点，规则为：

1. 如果优先级为0，该从节点不会被选举为主节点。
2. 哨兵优先选择低优先级的从节点

例如从节点S1与主节点在相同数据中心，该主节点的从节点S2在另一个数据中心。可以将S1优先级设为10，S2设为100。这样当两者都可用时，S1将优先被用于故障恢复。

### 哨兵和Redis认证

当主节点配置了客户端访问密码，从节点同样需要知道该密码来认证主节点。通过以下配置完成：

* 在主节点配置requirepass来设置密码。
* 在从节点配置masterauth来认证主节点。

当使用哨兵时，由于故障转移，主节点可能不止一个，且主节点也会变为从节点。因此，需要将上述两个配置参数在每个节点中配置。如果需要一个从节点不需认证，可以将该节点的优先级设为0，这样便可阻止从节点成为主节点。并且该从节点只配置masterauth。

## 进阶内容

### SDOWN和ODOWN状态

哨兵有两个宕机概念，一个为主观宕机（SDOWN），是指定哨兵实例本地的宕机状态。另一个为客观宕机（ODOWN），当有足够的哨兵有SDOWN状态时将满足ODOWN状态，并且使用SENTINEL is-master-down-by-addr指令从其他哨兵获得反馈。

从哨兵的角度，当它在is-master-down-after-milliseconds配置时间内没有收到有效的PING回复时会满足SDOWN条件。有效的PING回复有：

* +PONG回复
* -LOADING错误回复
* -MASTERDOWN错误回复

一个逻辑主节点在INFO返回内容中表名自己是从节点时，该主节点会被认为是宕机状态。SDOWN需要在配置的时间间隔内没有收到有效回复，如果配置时间间隔为30秒，每29秒收到一个回复，该实例仍会被认为在正常工作。

SDOWN不足以触发故障转移，它只意味着单个哨兵认为一个实例不可用了。故障转移必须达到ODOWN状态。SDOWN到ODOWN的切换没有使用强一致性算法，而是使用一种gossip协议的形式：如果指定哨兵在给定时间范围内从足够数量的哨兵处获得报告表明一个主节点不能工作了，SDOWN才会升级为ODOWN。如果之后不再有相关报告，该状态会被恢复。

ODOWN状态只适用于主节点。其不会用于从节点和哨兵中，只有SDOWN会。然而SDOWN依然有语义内涵，例如在SDOWN状态的从节点不会被哨兵选举来执行故障转移。

### 哨兵和从节点自动发现

哨兵与其他哨兵保持连接来互相检查可用性并交换消息。然而你无需在每个哨兵实例中配置其他哨兵的地址列表，因为哨兵会使用Pub/Sub功能来发现监控相同节点的其他实例。该特性通过向名为 \_\_sentinel\_\_:hello的频道发送hello消息实现。同样从节点列表也无需配置。

* 每个哨兵每2秒向监控的每个主从节点的\_\_sentinel\_\_:hello频道发布消息，表明自己在线，以及使用的IP、端口和运行ID
* 每个哨兵节点订阅每个主从节点的\_\_sentinel\_\_:hello频道来查找未知的哨兵。
* hello消息还包括了主节点的全部配置。如果接收的哨兵拥有的主节点配置较旧，它将理解更新配置。
* 在添加新哨兵前，现有哨兵会检查是否存在相同运行ID或地址的哨兵。如果有，所有符合条件的哨兵都将被删除。

### 重新配置实例

即使没有故障转移在执行，哨兵依然会一直尝试设置被监控实例的配置，尤其是：

* 声称是主节点的从节点会被配置为当前主节点的副本
* 连接到错误主节点的从节点会被重新配置为正确主节点的副本

为了重新配置从节点，哨兵必须观察错误配置一段时间，这段时间比广播新配置的时间要长。这样就阻止了使用旧配置的哨兵在接收到更新的配置之前就尝试修改从节点配置。

一直尝试强加当前配置的语义使得故障转移对网络分区的抗性更好

* 被故障转移的主节点在恢复可用后会被重新配置为从节点
* 配网络分区隔断的从节点一旦可用会被重新配置

本节最重要的内容是：哨兵是一个系统，其中每个进程会一直尝试向监控的实例强加最近的逻辑配置。

### 从节点评选和优先级

从节点评选过程会评估下列关于从节点的信息；

1. 与主节点断开连接的时间
2. 从节点优先级
3. 已处理的副本偏移量
4. 运行ID

从节点与主节点断开连接时间超过一定长度会被认为不适合用来故障转移，这段时间长度是配置的主节点超时时间（down-after-milliseconds 选项）的10倍与执行故障转移的哨兵认为的主节点不可用的持续时间之和，即：

<pre>
    (down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state
</pre>

选举只会考虑满足上述条件的从节点，并按下述条件排序：

1. 按slave-priority配置排序，低优先级优先
2. 如优先级相同，再检查从节点处理的副本偏移量，复制数据多的从节点会被选择
3. 以上两条都相同，则选择运行ID按字典排序更小的从节点。

## 算法与内部实现

### Quorum

每个被监控的主节点都须配置一个表决者数量（quorum），用来指定哨兵进程的数量，这些哨兵需要对主节点不可用状态达成一致从而触发故障转移。

* Quorum：需要检测到错误条件以使主节点被标记为ODOWN的哨兵进程数量。
* 故障转移由ODOWN状态触发
* 一旦触发故障转移，尝试故障转移的哨兵被要求向大多数哨兵请求授权（如果quorum设置的值大于哨兵数量的一半，则授权节点数量要大于quorum值）

### 配置纪元

要求从多数哨兵获取授权是由于一些重要原因：当哨兵得到授权，它将获得对正在被故障转移主节点来说唯一的配置纪元。当故障转移完成后，配置纪元用来给新配置记录版本。因为多数哨兵同意一个给定的版本已经分配给给定的哨兵，其他哨兵将无法再次使用该版本号。

此外哨兵有一条规则：如果哨兵对给定主节点故障的恢复为其他哨兵投票，那么过一段时间它将再次尝试转移相同的主节点。这段延迟时间可以用sentinel.conf的failover-timeout配置。这就意味着同一时间哨兵不会尝试故障转移相同的主节点，一个失败之后另一个哨兵过一段时间后会再一次尝试。

哨兵保证了活性属性，如果多数哨兵可用，其中之一最终会被授权来故障转移。哨兵还保证了安全性，每个哨兵故障会使用不同的配置纪元来转移同一个主节点。

### 配置传播

一旦哨兵成功转移了一个主节点，它将开始传播新的配置，以便其他哨兵会更新给定主节点的信息。为了认定故障转移成功，要求哨兵能够向被选的从节点发送SLAVEOF NO ONE指令，并且之后到主节点的切换可以从主节点的INFO输出中看出来。即使此时正在进行从节点的重配置，故障转移也会被认定为成功，并且系统会要求所有哨兵报告新配置。传播新配置的方式是由于我们需要每个故障转移是使用不同版本号授权的。

每个哨兵在主节点和所有从节点之间使用Pub/Sub消息持续广播主节点配置的版本，同时所有哨兵会等待消息来查看其它节点通告的配置是什么内容。配置是在\_\_sentinel\_\_:hello频道中广播的。

因为每个配置有不同的版本号，较大的版本总会生效。这意味着哨兵会保证第二个活性属性：可以互相通信的一组哨兵将收敛于版本号更高的同一配置。

### 网络分区下的一致性

使用哨兵的系统中有三种角色：

* Redis实例
* 哨兵实例
* 客户端

为了定义系统行为，我们不想考虑所有角色。

<pre>
            +-------------+
            | Sentinel 1  |----- Client A
            | Redis 1 (M) |
            +-------------+
                    |
                    |
+-------------+     |          +------------+
| Sentinel 2  |-----+-- // ----| Sentinel 3 |----- Client B
| Redis 2 (S) |                | Redis 3 (M)|
+-------------+                +------------+
</pre>

在上述例子的初始状态中，Redis 3是主节点。网络分区使得它被隔离，哨兵1和2开始故障转移，使得Redis 1成为新主节点。哨兵属性保证了哨兵1和2有主节点的新配置，然而3依然使用旧配置。如果有客户端与Redis 3在同一分区会发生什么呢？

客户端依然可以向Redis 3写数据。当网络恢复，Redis 3变为1的从节点，所有网络分区期间已写数据都将丢失。你可以通过配置决定上述情况是否可以发生：

* 如果使用Redis作为缓存，即使数据会丢失，客户端B依然可以向旧主节点写。
* 如果使用Redis作为存储，你需要配置系统来避免部分影响。

由于Redis使用异步复制，在此场景中无法避免完全的数据丢失。然而Redis 3和1的分歧可以使用下面配置来限制：

<pre>
min-slaves-to-write 1
min-slaves-max-lag 10
</pre>

使用上述配置，如果主节点无法向至少一个从节点写数据将停止接收写操作。无法向从节点写数据意思是从节点或者无法连接，或者无法发送异步确认超过max-lag秒。

### 哨兵持久化状态

哨兵状态会在哨兵配置文件中持久化。每次接收到或创建新主节点配置，配置和配置纪元值都会持久化到磁盘。停止和重启哨兵进程会很安全

### TILT模式

Redis哨兵非常依赖系统时间，例如为了了解一个实例是否可用，哨兵会记录最后一次PING指令的成功回复时间，并与当前时间比较从而知道它有多旧。如果系统时间以意想不到的方式发生了改变，或系统非常繁忙，或进程由于没写原因而阻塞，哨兵可能会有出乎意料的行为。

TILT模式是一种特殊的保护模式，当检测到一些降低系统可靠性的的奇怪事情时，一个哨兵便会进入这种模式。哨兵的时钟中断通常是每秒10次，因此我们预期在两次时钟中断间会大约消逝100毫秒。

哨兵做的事情就是在调用时钟中断时注册之前的实际，并与当前调用时的时间比较。如果时间差是负数或意外的大（2秒或以上），哨兵将进入TILT模式（如果已经进入将推迟退出TILT模式）

在TILT模式时哨兵会继续监控一切除了：

* 完全停止动作。
* 开始对is-master-down-by-addr请求做否定回复，因为检测故障的能力不再可信。

如果30秒的时间内一切正常，哨兵会退出TILT模式。
